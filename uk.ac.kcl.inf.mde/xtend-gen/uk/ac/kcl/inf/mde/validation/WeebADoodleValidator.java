/**
 * generated by Xtext 2.29.0
 */
package uk.ac.kcl.inf.mde.validation;

import java.util.HashSet;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import uk.ac.kcl.inf.mde.weebADoodle.Board;
import uk.ac.kcl.inf.mde.weebADoodle.CameraShotStatement;
import uk.ac.kcl.inf.mde.weebADoodle.DescriptionStatement;
import uk.ac.kcl.inf.mde.weebADoodle.LightingStatement;
import uk.ac.kcl.inf.mde.weebADoodle.PositionStatement;
import uk.ac.kcl.inf.mde.weebADoodle.Scene;
import uk.ac.kcl.inf.mde.weebADoodle.SceneObject;
import uk.ac.kcl.inf.mde.weebADoodle.WeebADoodlePackage;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class WeebADoodleValidator extends AbstractWeebADoodleValidator {
  public static final String INVALID_NAME = "invalidName";

  public static final String INVALID_DESCRIPTION_SIZE = "invalidDescriptionSize";

  public static final String INVALID_SCENE_ID = "duplicatedSceneID";

  public static final String INVALID_OBJECT_LENGTH = "invalidObjectLength";

  public static final String INVALID_POSITION_VAlUE = "invalidPositionValue";

  public static final String INVALID_CHARACTERS_IN_SCENE = "invalidSceneCharacters";

  public static final String INVALID_Objects_IN_SCENE = "invalidSceneObjects";

  public static final String INVALID_BACKGROUND = "invalidBackgroundInScene";

  public static final String INVALID_LIGHTING_STATEMENT = "invalidLightingStatement";

  public static final String INVALID_CAMERA_STATEMENT = "invalidCameraStatement";

  @Check
  public void checkIfNameIsTooShort(final uk.ac.kcl.inf.mde.weebADoodle.Character chr) {
    int _length = chr.getName().length();
    boolean _lessEqualsThan = (_length <= 1);
    if (_lessEqualsThan) {
      this.warning("Name should be longer than 1 characters", chr, WeebADoodlePackage.Literals.CHARACTER__NAME, WeebADoodleValidator.INVALID_NAME);
    }
  }

  @Check
  public void checkDescriptionLength(final DescriptionStatement descrip) {
    int _length = descrip.getDescription().length();
    boolean _lessEqualsThan = (_length <= 8);
    if (_lessEqualsThan) {
      this.warning("Description should be longer than 8 characters", descrip, WeebADoodlePackage.Literals.DESCRIPTION_STATEMENT__DESCRIPTION, WeebADoodleValidator.INVALID_DESCRIPTION_SIZE);
    }
  }

  @Check
  public void checkObjectNotNull(final SceneObject obj) {
    int _length = obj.getName().length();
    boolean _lessEqualsThan = (_length <= 0);
    if (_lessEqualsThan) {
      this.warning("An object should not have an empty name", obj, WeebADoodlePackage.Literals.SCENE_OBJECT__NAME, WeebADoodleValidator.INVALID_OBJECT_LENGTH);
    }
  }

  @Check
  public void checkUniqueSceneNames(final Board board) {
    final HashSet<String> names = CollectionLiterals.<String>newHashSet();
    EList<Scene> _scenes = board.getScenes();
    for (final Scene scene : _scenes) {
      boolean _add = names.add(scene.getName());
      boolean _not = (!_add);
      if (_not) {
        this.warning("Scene IDs should be unique", scene, WeebADoodlePackage.Literals.SCENE__NAME, WeebADoodleValidator.INVALID_SCENE_ID);
      }
    }
  }

  @Check
  public void checkPositionsNotNull(final PositionStatement pos) {
    int _length = pos.getPosition().length();
    boolean _lessEqualsThan = (_length <= 0);
    if (_lessEqualsThan) {
      this.warning("Position should not be empty", pos, WeebADoodlePackage.Literals.POSITION_STATEMENT__POSITION, WeebADoodleValidator.INVALID_POSITION_VAlUE);
    }
  }

  @Check
  public void checkUniqueCharactersInScene(final Scene scene) {
    final HashSet<String> chars = CollectionLiterals.<String>newHashSet();
    EList<uk.ac.kcl.inf.mde.weebADoodle.Character> _characters = scene.getCharacters();
    for (final uk.ac.kcl.inf.mde.weebADoodle.Character chr : _characters) {
      boolean _add = chars.add(chr.getName());
      boolean _not = (!_add);
      if (_not) {
        this.warning("Characters should be unique within scenes", scene, WeebADoodlePackage.Literals.SCENE__NAME, WeebADoodleValidator.INVALID_CHARACTERS_IN_SCENE);
      }
    }
  }

  @Check
  public void checkUniqueObjectsInScene(final Scene scene) {
    final HashSet<String> objs = CollectionLiterals.<String>newHashSet();
    EList<SceneObject> _objects = scene.getObjects();
    for (final SceneObject obj : _objects) {
      boolean _add = objs.add(obj.getName());
      boolean _not = (!_add);
      if (_not) {
        this.warning("Objects should be unique within scenes", scene, WeebADoodlePackage.Literals.SCENE__NAME, WeebADoodleValidator.INVALID_Objects_IN_SCENE);
      }
    }
  }

  @Check
  public void checkBackgroundNotNull(final Scene scene) {
    int _length = scene.getBackground().length();
    boolean _lessEqualsThan = (_length <= 0);
    if (_lessEqualsThan) {
      this.warning("Background should not be empty", scene, WeebADoodlePackage.Literals.SCENE__BACKGROUND, WeebADoodleValidator.INVALID_BACKGROUND);
    }
  }

  @Check
  public void checkLightingNotNull(final LightingStatement light) {
    int _length = light.getSource().length();
    boolean _lessEqualsThan = (_length <= 0);
    if (_lessEqualsThan) {
      this.warning("Source  of lighting cannot be empty", light, WeebADoodlePackage.Literals.LIGHTING_STATEMENT__SOURCE, WeebADoodleValidator.INVALID_LIGHTING_STATEMENT);
    }
    int _length_1 = light.getDirection().length();
    boolean _lessEqualsThan_1 = (_length_1 <= 0);
    if (_lessEqualsThan_1) {
      this.warning("Direction of lighting cannot be empty", light, WeebADoodlePackage.Literals.LIGHTING_STATEMENT__DIRECTION, WeebADoodleValidator.INVALID_LIGHTING_STATEMENT);
    }
  }

  @Check
  public void checkCameraNotNull(final CameraShotStatement camera) {
    int _length = camera.getCameraShot().length();
    boolean _lessEqualsThan = (_length <= 0);
    if (_lessEqualsThan) {
      this.warning(" Camera Shot cannot be empty", camera, WeebADoodlePackage.Literals.CAMERA_SHOT_STATEMENT__CAMERA_SHOT, WeebADoodleValidator.INVALID_CAMERA_STATEMENT);
    }
    int _length_1 = camera.getCameraAngle().length();
    boolean _lessEqualsThan_1 = (_length_1 <= 0);
    if (_lessEqualsThan_1) {
      this.warning("Camera Angle cannot be empty", camera, WeebADoodlePackage.Literals.CAMERA_SHOT_STATEMENT__CAMERA_ANGLE, WeebADoodleValidator.INVALID_CAMERA_STATEMENT);
    }
  }
}
